//import { dataSceneTest } from "./scene-test";

// TODO scene data must be in some file or something
let dataSceneTest = [
  ["wall",0,512,0.4266,0.4266,"../img/whitewall.jpg"],
  ["man",704,640,0.3101,0.3101,"../img/man.png"],
];




let jsScreen = null;
let screenContext = null;
let preloader = null;
let imgBackground = null;

let userView = null;
let currentScene = null;

let loaderMaxItems = 0;
let loaderNumOfItems = 0;




class classUserView {
  cameraXPos;
  cameraYPos;
  cameraZoom;
  sceneXOffset;
  sceneYOffset;
  mousePosX;
  mousePosY;

  constructor() {
    this.cameraXPos = 0;
    this.cameraYPos = 0;
    this.cameraZoom = 1;
    this.sceneXOffset = 0;
    this.sceneYOffset = 0;
    this.mousePosX = 0;
    this.mousePosY = 0;
  }

  calcOffset() {
    this.sceneXOffset = jsScreen.width/2-this.cameraXPos*this.cameraZoom;
    this.sceneYOffset = jsScreen.height/2-this.cameraYPos*this.cameraZoom;
  }

  drawBackground() {
    let gridSize = imgBackground.width * this.cameraZoom;
    let totalX = this.sceneXOffset%gridSize-gridSize;
    while(totalX < jsScreen.width) {

      let totalY = this.sceneYOffset%gridSize-gridSize;
      while(totalY < jsScreen.height) {

        screenContext.drawImage(imgBackground, totalX, totalY, gridSize, gridSize);

        totalY += gridSize;}
      totalX += gridSize;}

    // тут отрисовываем текст
    screenContext.fillStyle = "white";



    screenContext.font = (48 * this.cameraZoom) + "px calibri";
    screenContext.fillText("Work in progress",this.sceneXOffset-155*this.cameraZoom,this.sceneYOffset-10*this.cameraZoom);

    screenContext.font = (24 * this.cameraZoom) + "px calibri";
    screenContext.fillText("Please, be patient",this.sceneXOffset-100*this.cameraZoom,this.sceneYOffset+20*this.cameraZoom);
  }

  drawSceneObject(object) {
    screenContext.drawImage(object.objectImage,
        this.sceneXOffset+object.objectPositionX*this.cameraZoom, this.sceneYOffset+object.objectPositionY*this.cameraZoom,
        object.objectSizeX*object.objectImage.width*this.cameraZoom, object.objectSizeY*object.objectImage.height*this.cameraZoom);

  }

  drawScene(scene) {
    let thisView = this;
    scene.objectArray.forEach(function(item, i, arr) {
      thisView.drawSceneObject(item);
    });
  }

}


class classSceneObject {
  objectName;
  objectPositionX;
  objectPositionY;
  objectSizeX;
  objectSizeY;
  objectImage;
  objectImgPath;

  constructor(data) {
    this.objectImage = new Image();
    this.objectImage.onload = resourceOnLoad;

    console.log("  load (" + data[0] + ")");

    if(data === undefined) {
      this.objectName = "";
      this.objectPositionX = 0;
      this.objectPositionY = 0;
      this.objectSizeX = 1;
      this.objectSizeY = 1;
      this.objectImgPath = "";
    } else {
      this.objectName = data[0];
      this.objectPositionX = data[1];
      this.objectPositionY = data[2];
      this.objectSizeX = data[3];
      this.objectSizeY = data[4];
      this.objectImgPath = data[5];
    }
  }

  loadImage() {
    this.objectImage.src = this.objectImgPath;
  }
}


class classScene {
  objectArray;

  constructor() {
    this.objectArray = [];
  }

  addObject(object) {
    this.objectArray.push(object);
  }

  loadObjectsFromData(data) {
    console.log("Start loading data");

    let thisScene = this;
    data.forEach(function(item, i, arr) {
      thisScene.addObject( new classSceneObject(item) );
    });
  }

  loadImages() {
    this.objectArray.forEach(function(item, i, arr) {
      loaderMaxItems++;
      item.loadImage();
    });
  }
}





// when window onload fired then start to do stuff
window.onload = function(e) {
  jsScreen = document.getElementById("js-screen");
  preloader = document.getElementById("preloader");

  userView = new classUserView();
  currentScene = new classScene();


  currentScene.loadObjectsFromData( dataSceneTest );


  // background
  loaderMaxItems++;
  imgBackground = new Image();
  imgBackground.onload = resourceOnLoad;
  imgBackground.src = "../img/bg_grid.png";


  currentScene.loadImages();


  //show body
  document.body.style.display = "block";

  //init screen
  initScreen();
};


window.onresize = function(e) {
  resizeScreen();
  drawCall();
};


function initScreen() {
  screenContext = jsScreen.getContext('2d');

  screenContext.imageSmoothingEnabled = false;
  screenContext.imageSmoothingQuality = "low";

  let mousePosXEvStart = 0;
  let mousePosYEvStart = 0;
  let mouseRightIsActive = false;

  let cameraPosXEvStart = 0;
  let cameraPosYEvStart = 0;

  jsScreen.style.cursor = "default";

  jsScreen.onmousemove = function(e) {
    userView.mousePosX = e.clientX / userView.cameraZoom;
    userView.mousePosY = e.clientY / userView.cameraZoom;

    if(mouseRightIsActive) {
      //console.log("m calc : " + cameraXPos + " = - (" + mousePosX + " - " + mousePosXEvStart + ")");
      userView.cameraXPos = cameraPosXEvStart - (userView.mousePosX - mousePosXEvStart);
      userView.cameraYPos = cameraPosYEvStart - (userView.mousePosY - mousePosYEvStart);
      drawCall();
    }
  };

  jsScreen.onmousedown = function(e) {
    if(e.which === 2) {
      mousePosXEvStart = userView.mousePosX;
      mousePosYEvStart = userView.mousePosY;

      cameraPosXEvStart = userView.cameraXPos;
      cameraPosYEvStart = userView.cameraYPos;

      jsScreen.style.cursor = "grabbing";

      //console.log("m down : " + mousePosXEvStart + " : " + mousePosYEvStart);

      mouseRightIsActive = true;
    }
  };

  jsScreen.onmouseup = function(e) {
    if(e.which === 2) {
      //console.log("m up");
      mouseRightIsActive = false;

      jsScreen.style.cursor = "default";
    }
  };

  jsScreen.onwheel = function(e) {
    e.preventDefault();

    userView.cameraZoom *= e.deltaY < 0 ? 1.25 : 0.75;
    if(userView.cameraZoom < 0.25) userView.cameraZoom = 0.25;
    if(userView.cameraZoom > 5) userView.cameraZoom = 5;
    drawCall();
    //console.log("m wheel : " + cameraZoom);
  };

  jsScreen.onmouseleave = function(e) {
    mouseRightIsActive = false;

    jsScreen.style.cursor = "default";
  };

  jsScreen.addEventListener('contextmenu', function(evt) {
    evt.preventDefault();
  }, false);

  resizeScreen();
}


function resizeScreen() {
  let jsScreenSize = jsScreen.getBoundingClientRect();
  console.log("Container size: " + jsScreenSize.width + "; " + jsScreenSize.height);

  jsScreen.width = jsScreenSize.width;
  jsScreen.height = jsScreenSize.height;
}


function resourceOnLoad(e) {
  loaderNumOfItems++;

  preloader.innerHTML = "Loading... " + (loaderNumOfItems / loaderMaxItems * 100 | 0) + "%";

  if(loaderNumOfItems === loaderMaxItems) {
    preloader.style.display = "none";
    drawCall();
  }
}


function drawCall() {
  let timeStart = Date.now();
  screenContext.fillStyle = "black";
  screenContext.fillRect(0, 0, jsScreen.width, jsScreen.height);

  userView.calcOffset();
  userView.drawBackground();
  userView.drawScene(currentScene);

  let timeEnd = Date.now();

  //console.log("draw call : " + (timeEnd - timeStart) + "ms");
}